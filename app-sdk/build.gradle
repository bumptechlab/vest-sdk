plugins {
    id 'com.android.library'
    id 'org.jetbrains.kotlin.android'
    id 'maven-publish'
    id 'com.kezong.fat-aar'
}
apply from: './publish.gradle' //aar发布脚本
apply from: '../plugins/pack.gradle'    //aar输出脚本
apply from: '../plugins/code-plugin.gradle'

def androidConfig = rootProject.ext.android
def dependenciesConfig = rootProject.ext.dependencies
def proguardDictConfig = rootProject.ext.proguardDict
def namespaces = rootProject.ext.namespaces
def mavenConfig = rootProject.ext.maven
def projectName = androidConfig.projectName

def execCommand(command) {
    def commandProcess = command.execute()
    commandProcess.in.eachLine { line -> println line }
    commandProcess.err.eachLine { line -> println line }
    commandProcess.waitFor()
}

//ShellPlugin插件需要每次Build之前clean
project.afterEvaluate {
    println("> ${projectName}: project afterEvaluate")
    android.libraryVariants.all { variant ->
        variant.outputs.each { output ->
            def capitalizedVariant = variant.name.capitalize()
            def assembleVariantTask = project.tasks."assemble${capitalizedVariant}"
            assembleVariantTask.dependsOn clean
            println("> ${projectName}: ${assembleVariantTask} dependsOn clean")
        }
    }
}

fataar {
    /**
     * If transitive is true, local jar module and remote library's dependencies will be embed. (local aar module does not support)
     * If transitive is false, just embed first level dependency
     * Default value is false
     * @since 1.3.0
     */
    transitive = true
}

android {
    namespace namespaces.appsdk
    compileSdk androidConfig.compileSdkVersion

    defaultConfig {
        minSdkVersion androidConfig.minSdkVersion
        targetSdkVersion androidConfig.targetSdkVersion
        versionName mavenConfig.version
        multiDexEnabled true
        consumerProguardFiles "../proguard/consumer-rules.pro"
        // 国际化资源配置, 只打包以下国家的资源
        resConfigs 'en', 'hi', 'in', 'pt'
    }

    buildTypes {
        debug {
            debuggable true
            jniDebuggable true
            renderscriptDebuggable true
            minifyEnabled false
            shrinkResources false
            //R8混淆开启之后解决APP打开类加载时找不到类的问题,指定文件来放置启动时需要优先加载的类
            multiDexKeepFile file("maindexlist.txt")
        }
        release {
            debuggable false
            jniDebuggable false
            renderscriptDebuggable false
            minifyEnabled false
            shrinkResources false
            //R8混淆开启之后解决APP打开类加载时找不到类的问题,指定文件来放置启动时需要优先加载的类
            multiDexKeepFile file("maindexlist.txt")
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro', '../proguard/consumer-rules.pro'
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_11
        targetCompatibility JavaVersion.VERSION_11
    }

    kotlinOptions {
        jvmTarget = "11"
    }

    packagingAAR(project, android, mavenConfig.artifactIdSdk)
}

def taskName = getGradle().getStartParameter().getTaskNames().toString()

android.libraryVariants.all { variant ->
    variant.outputs.each { output ->
        def capitalizedVariant = variant.name.capitalize()
        println("> ${projectName}: Task${taskName} variant: ${capitalizedVariant}")
        //1.在当前构建任务中生成字典
        def shouldCreateProguardDict = taskName.contains(capitalizedVariant)
        if (shouldCreateProguardDict) {
            println("> ${projectName}: Task${taskName} 开始创建混淆字典")
            def libDictJar = new File(project.projectDir, "../tools/proguard-tools/libs/lib-proguard-dict.jar")
            def dictFiles = [
                    new File(project.projectDir, "prog-dict-class.txt"),
                    new File(project.projectDir, "prog-dict-package.txt"),
                    new File(project.projectDir, "prog-dict-field-method.txt")
            ]
            def lines = proguardDictConfig.lines
            def characters = proguardDictConfig.characters
            def charsets = proguardDictConfig.charsetsAppSdk
            //打印help信息（字符集索引）
            execCommand("java -jar ${libDictJar} -h")
            for (i in 0..<dictFiles.size()) {
                def curDictFile = dictFiles.get(i);
                if (!curDictFile.exists()) {
                    execCommand("java -jar ${libDictJar} -o ${curDictFile} -c ${characters} -l ${lines} -ch ${charsets}")
                }
            }
        }
    }
}


dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar', '*.aar'])
    implementation "androidx.appcompat:appcompat:$dependenciesConfig.androidxAppcompatVersion"
    implementation "androidx.multidex:multidex:$dependenciesConfig.androidxMultidexVersion"
    implementation "androidx.annotation:annotation:$dependenciesConfig.androidxAnnotation"
    implementation "com.android.installreferrer:installreferrer:$dependenciesConfig.installreferrerVersion"
    implementation "com.google.android.gms:play-services-ads-identifier:$dependenciesConfig.googlePlayServiceVersion"

    implementation "io.reactivex.rxjava3:rxjava:$dependenciesConfig.rxJavaVersion"
    implementation "io.reactivex.rxjava3:rxandroid:$dependenciesConfig.rxAndroidVersion"
    implementation "com.squareup.retrofit2:retrofit:$dependenciesConfig.retrofit2Version"
    implementation "com.squareup.retrofit2:adapter-rxjava3:$dependenciesConfig.retrofit2Version"
    implementation "com.squareup.okhttp3:okhttp:$dependenciesConfig.okhttpVersion"
    implementation "com.squareup.okhttp3:logging-interceptor:$dependenciesConfig.okhttpVersion"

    compileOnly project(':app-core')
    compileOnly project(':lib-util')
}
